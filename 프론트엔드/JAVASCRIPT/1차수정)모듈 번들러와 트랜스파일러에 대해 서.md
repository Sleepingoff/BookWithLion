# 1차수정)모듈 번들러와 트랜스파일러에 대해 설명해주세요.

신명진(AI)

#꾸러미 # 웹 팩 #바벨

## **답변 드리겠습니다!**

<aside>
📌 (283 자)
모듈 번들러란 웹 앱에 필요한 JS, CSS 등과 같은 여러 모듈을 하나의 파일로 만들어주는 도구를 말합니다. 코드를 최적화하고 파일 간의 의존성 관계를 정리해 압축하여 처리 속도를 높이고 같은 변수의 다중 사용이 가능하게 하는 장점이 있습니다. 트랜스파일은 한 언어를 비슷한 정도의 다른 언어로 변환 시키는 것입니다. 대표적인 트랜스파일러로 바벨이 있는데 최근에는 웹팩을 더 많이 쓰는 추세입니다. 웹 팩에 있는 babel-loader를 사용하여 번들링 과정에서 트랜스파일링도 일어나므로 더 효율적입니다.

</aside>

모듈

전통적인 자바스크립트 개발 방식은 기능별 또는 페이지별로 자바스크립트 파일을 분리하고 HTML에서 `<script>` 태그로 로드하는 것이었다. 하지만 이 방식은 의존성이 있는 코드 사이에 순서를 보장하기 어렵고, 여러 개의 파일을 로드할 때 일부 파일의 문제로 전체 스크립트를 실행하지 못할 수도 있다. 이러한 문제를 해결하기 위해 모듈 단위의 개발 방식이 등장하게 되었다. 그리고 모듈 단위 스코프를 지원하지 않는 브라우저 환경에서 모듈 단위 개발을 위한 노력이 계속되면서 다양한 모듈 포맷이 등장하게 되었다.

**모듈번들러**

  모듈 번들러란 규모가 큰 코드 베이스에서 파일을 최적화 하여 모듈 단위를 의존성 관계에 따라 묶어 주는 도구입니다. 모듈 시스템을 이용하면 필요한 모듈만 불러와서 사용할 수 있기 때문에 효율적입니다. CommonJS나 일부 ES6 Module로 작성된 코드는 바로 실행할 수 없어 브라우저 환경에서 잘 실행되도록 변형해주어야 합니다. 모듈번들러에는 webpack, rollup, fusebox, parcel 등이 있습니다.
  

  모듈번들러는 다음과 같은 기능을 가집니다.

하나로 묶어주는 도구
- 모듈 단위로 관리하여 유지보수 용이: 모듈 A가 B를 필요로 할 때 A가 B에 의존한다고 합니다. 이전에는 직접 의존성 관계를 파악하여 스크립트 순서를 지정해줘야 했지만 번들러는 자동으로 정리하여 관련된 것끼리 번들을 생성합니다.   
- 요청 횟수 감소 : 파일을 하나로 묶어서 브라우저에 요청을 보내게 되므로 요청 횟수가 줄어듭니다.

최적화
- tree shacking : 필요없는 코드를 제거하여 파일의 크기를 줄이고 번들링 시간을 절약합니다.
- HMR(hot module replacement) : 변경된 코드를 감지하여 최신 코드를 자동적으로 반영하여 시간이 단축되고 변경사항만 업데이트 하므로 효율적입니다.
- code splitting : 모듈 번들러가 의존성 있는 모듈만 한데 모아 Http 통신 횟수를 줄였습니다. 그러나 이런 방식으로 하나의 번들 파일이 커져 브라우저 로딩 시간이 길어지게 되어 스플리팅이 생겼습니다. 큰 번들을 작은 번들로 분할 후 필요한 경로에만 제공하여 최적화 시킵니다.

![Untitled](Untitled%2053.png)

**트랜스파일**

트랜스파일은 컴파일의 일부분으로 한 언어를 추상화 정도가 비슷한 다른 언어로 컴파일 하는 것이 트랜스파일 입니다. 높은 버전의 자바스크립트 코드를 바벨을 이용하여 다운 레벨 트랜스파일링 시키는 것을 그 예로 들 수 있습니다.

## **이런 질문도 나올 수 있어요!**

### 

## **만반의 준비! 이것도 알아둘까요?**

### 

### Webpack 을 왜 사용하는지 설명하시오.

### Babel 을 왜 사용하는지 설명하시오.

바벨로더는 웹팩이 모듈을 번들링할 때  바벨을 사용하도록 해준다.

---

⚠️여기에 각주내용 및 출처, 그림 제목 등에 대해서 달아주세요!!!

[https://velog.io/@timosean/Web-번들러Bundler의-개념과-필요성](https://velog.io/@timosean/Web-%EB%B2%88%EB%93%A4%EB%9F%ACBundler%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%95%84%EC%9A%94%EC%84%B1)

[https://webpack.js.org/](https://webpack.js.org/)

[모듈번들러(Module Bundler)란? feat. webpack ,vite (tistory.com)](https://saemaul-dev.tistory.com/11)

[쉽게 이해하자, 웹팩(Webpack)이란? - 모듈 번들러(Module Bundler) - 검은바닷가재 (tistory.com)](https://blacklobster.tistory.com/16)

[[CS] 모듈 번들러와 트랜스파일러 (velog.io)](https://velog.io/@hameee/CS-%EB%AA%A8%EB%93%88-%EB%B2%88%EB%93%A4%EB%9F%AC%EC%99%80-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8C%8C%EC%9D%BC%EB%9F%AC)

[번들러와 트랜스파일러 (velog.io)](https://velog.io/@beberiche/%EB%B2%88%EB%93%A4%EB%9F%AC%EC%99%80-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EC%97%90-%EB%8C%80%ED%95%B4-%EB%A7%90%EC%94%80%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

[🖥️ 컴파일 / 트랜스파일 / 인터프리터 비교 쉽게 설명 (tistory.com)](https://inpa.tistory.com/entry/CS-%F0%9F%96%A5%EF%B8%8F-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8C%8C%EC%9D%BC-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EB%B9%84%EA%B5%90-%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85)

[https://ui.toast.com/fe-guide/ko_BUNDLER](https://ui.toast.com/fe-guide/ko_BUNDLER)

[https://velog.io/@wynter_j/Bundler-JavaScript-번들러-그리고-Webpack-Parcel-Rollup-Vite](https://velog.io/@wynter_j/Bundler-JavaScript-%EB%B2%88%EB%93%A4%EB%9F%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Webpack-Parcel-Rollup-Vite)...-1

[https://velog.io/@timosean/Web-번들러Bundler의-개념과-필요성](https://velog.io/@timosean/Web-%EB%B2%88%EB%93%A4%EB%9F%ACBundler%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%95%84%EC%9A%94%EC%84%B1)

[https://poiemaweb.com/es6-module](https://poiemaweb.com/es6-module)

---

 **웹 팩**

번들링을 도와주는 라이브러리로 웹 팩이 있습니다. 파일을 하나로 묶는 작업은 필수는 아니지만 웹이 고도화되고 자바스크립트가 복잡해지면서 코드의 관리, 성능 개선, 유지 보수의 역할이 더 중요해지게 되었습니다. 이러한 문제를 해결하는 하나의 수단으로 웹 팩 등을 이용한 모듈 번들링의 방법이 사용되고 있습니다.

**모듈번들러 등장 배경(왜)**

최초의 자바스크립트는 아주 간단한 모듈 시스템 만을 제공했습니다. HTML에서 JavaScript 원본 소스를 제공하고 브라우저에서 이를 순서대로 로드하는 방식이었습니다.

예를 들어 여러 JavaScript 파일로 구성된 웹 애플리케이션을 구축한다고 가정해보겠습니다. 아래와 같이 스크립트 태그를 통해 JavaScript 파일을 html에 추가합니다.

```jsx
<html>
  <script src="/src/foo.js"></script>
  <script src="/src/bar.js"></script>
  <script src="/src/baz.js"></script>
  <script src="/src/qux.js"></script>
  <script src="/src/quux.js"></script>
</html>
```

각 파일에는 별도의 Http요청이 필요해 한 애플리케이션을 실행시키기 위해 5번의 왕복 요청을 해야 합니다. 5개 파일을 묶어 하나의 파일로 만든다면 더 효율적 입니다.

```jsx
<html>
  <script src="/dist/bundle.js"></script>
</html>
```

그런데 이 방법은 dist.budle.js의 생성 과정에서 각 파일의 순서를 알 수 없다는 점과 스크립트를 로드한 전역 컨텍스트에서 모듈간 충돌이 발생한다는 문제가 있습니다. foo.js에서 선언한 변수가 bar.js에서도 선언될 경우 나중에 호출된 bar.js의 변수로 재정의 되어 foo.js의 파일이 제대로 동작하지 않게 되는 것입니다. 즉, 모듈 간의 스코프가 구분되지 않아 다른 파일을 오염시키는 문제가 생깁니다. 웹 시장이 커지고 컨텐츠들이 많아지면서 파일 간의 충돌과 느려지는 속도를 개선하기 위해 모듈 번들러가 발전하게 되었습니다.

---

### 컴파일

한 언어로 작성된 소스 코드를 다른 언어로 변환하는 것이 컴파일입니다. 초기 스캔 시간이 오래 걸리나 한 번 실행 파일이 만들어지고 나면 빠르게 동작합니다. 기계어 번역과정에서 많은 메모리를 사용합니다. 전체 코드를 스캔하는 과정에서 오류를 찾을 수 있기 때문에 실행 전에 오류를 알 수 있습니다. 프로그램의 코드가 유출되지 않고 프로그램 실행 파일 전체를 전송해야 하므로 용량이 큽니다. C, C++처럼 비교적 저수준인 언어가 있습니다.

### 인터프리터

사람이 알아보기 쉬운 프로그래밍 언어로 작성한 코드를 프로그램 실행시 한 번에 한 문장 씩 즉시 기계어로 번역합니다. 컴파일러와 같은 오브젝트 코드 생성 과정이 없기 때문에 메모리 효율이 좋다는 장점이 있지만 프로그램 실행 후에 오류를 발견하므로 사용성의 문제가 있고 프로그램 실행 속도도 느리다는 단점이 있습니다. 파이썬과 루비가 있습니다.