---
created: 2023-10-07T09:26
updated: 2023-10-07T18:27
---
# 호이스팅에 대해서 설명해주세요!

<aside>
💡 지식 이해력과 커뮤니케이션 능력을 평가하기 위해서입니다. 복잡한 아이디어를 명확하고 간결하게 설명할 수 있는 능력은 기술 분야를 비롯한 많은 직업에서 중요한 기술 중 하나입니다. 이외에도, 문제 해결과 비판적 사고 접근 방식, 지식을 실제 상황에 적용하는 능력 등을 확인하고자 할 수 있습니다.

</aside>

- **요약**

 호이스팅(Hoisting)은 J런타임 이전에 코드를 평가하는 단계에서 변수와 함수 선언이 해당 스코프(scope)의 최상단으로 끌어올려지는 것을 의미합니다. 즉, 런타임에 변수나 함수 선언문 이전에도 접근할 수 있다는 것입니다.

- **상세**

 JavaScript에서는 변수를 선언할 때 var, let, const 키워드를 사용합니다. 이 때, var 키워드로 선언한 변수는 선언하기 전에도 접근할 수 있습니다. 이는 호이스팅 덕분에 가능한 것입니다. JavaScript 엔진은 코드를 실행하기 전에 변수와 함수를 메모리에 저장합니다. 변수나 함수가 선언되기 전에도 해당 변수나 함수를 사용하면, JavaScript 엔진은 메모리에서 해당 변수나 함수를 찾아 사용합니다. 이렇게 변수나 함수를 선언하기 전에 접근할 수 있는 것을 호이스팅이라고 합니다.

 변수의 경우, 키워드에 따라 실행 컨텍스트에 등록되는 과정이 다르기 때문에 접근에 한계가 있을 수 있습니다. var 키워드는 호이스팅되면서 undefined라는 값으로 초기화를 진행하는 반면, let, const 키워드는 일시적 사각 지대에 있기 때문에 호이스팅이 일어나도 접근이 불가합니다. 런타임 시 선언문이 위치한 곳까지 코드를 읽은 후 초기화 단계를 거칩니다.

 함수의 경우, 함수 선언문(function declaration)과 함수 표현식(function expression)에서 모두 발생합니다. 함수 선언문에서는 함수 이름이 호이스팅됩니다. 함수 표현식에서는 변수 이름이 호이스팅됩니다. 따라서 함수 선언문으로 함수를 선언하면, 해당 함수를 선언하기 전에도 호출할 수 있습니다.

 호이스팅은 코드의 가독성을 저해할 수 있습니다. 코드를 읽을 때, 변수나 함수가 선언되어 있는 위치를 찾기 어려울 수 있습니다. 따라서 호이스팅의 특성을 이해하고, 코드를 작성할 때 가독성을 고려해야 합니다.

 JavaScript에서는 변수와 함수를 선언하기보다는 함수 표현식을 사용하는 것이 더 안전하다는 의견도 있습니다. 함수 표현식은 변수에 함수를 할당하는 방식으로 함수를 생성합니다. 이렇게 생성된 함수는 호이스팅되지 않기 때문에, 런타임 에러를 줄일 수 있습니다.

### 꼬리 질문

1. **let, const 키워드를 사용하면 호이스팅이 일어나지 않나요?**

let, const 키워드는 호이스팅이 일어납니다. 그러나 호이스팅이 일어나더라도 해당 변수는 temporal dead zone에 빠지기 때문에 변수를 선언하기 전에 사용하려고 하면 ReferenceError가 발생합니다. 따라서, let, const 키워드를 사용하는 경우에도 호이스팅이 발생하지만, 변수는 선언과 초기화가 모두 이루어진 이후에 사용할 수 있습니다. 최근 JavaScript의 표준인 ECMAScript 6에서는 var 키워드보다 let, const 키워드를 사용하여 변수를 선언하도록 권장하고 있습니다.

### 추가 개념

**Temporal Dead Zone (TDZ)**

TDZ란 let, const 키워드로 변수를 선언할 때 발생하는 현상입니다. TDZ는 해당 변수가 선언되기 전까지 변수를 참조할 수 없게 만듭니다. 즉, 변수가 선언되기 전에 해당 변수를 사용하려고 하면 ReferenceError가 발생합니다. TDZ는 블록 스코프에서만 발생하며, 함수 스코프에서는 발생하지 않습니다.

**Function Hoisting**

함수 선언문에서는 함수 이름이 호이스팅됩니다. 따라서 함수 선언문으로 함수를 선언하면, 해당 함수를 선언하기 전에도 호출할 수 있습니다. 하지만, 함수 표현식에서는 변수 이름만 호이스팅되고 함수 자체는 호이스팅되지 않습니다.

**Variable Shadowing**

Variable Shadowing은 변수가 다른 변수를 가리는 현상을 말합니다. 예를 들어, 함수 내에서 전역 변수와 동일한 이름의 지역 변수를 선언하면, 해당 함수에서는 지역 변수가 전역 변수를 가리게 됩니다. 이 경우, 전역 변수에 접근하려면 전역 객체인 window 객체를 사용해야 합니다.

**Block Scope**

Block Scope는 코드 블록 내에서 변수가 선언되면, 해당 변수는 블록 외부에서 접근할 수 없습니다. 이러한 변수는 블록 스코프(scope)를 가진다고 말할 수 있습니다. Block Scope는 let, const 키워드로 변수를 선언할 때 사용됩니다.

**Lexical Scope**

Lexical Scope는 함수를 중심으로 스코프를 정의하는 방식을 말합니다. 이는 함수를 선언할 때 해당 함수가 선언된 위치에 따라 스코프가 결정된다는 것을 의미합니다. 따라서, 함수 내에서 선언된 변수는 해당 함수 내에서만 접근할 수 있습니다. 이러한 스코프를 정적 스코프(Static Scope)라고도 합니다.

**IIFE (Immediately Invoked Function Expression)**

IIFE란 함수를 정의하고 즉시 실행하는 방식을 말합니다. 이를 사용하면 전역 스코프를 오염시키지 않으면서, 즉시 실행되는 코드 블록을 만들 수 있습니다. IIFE는 함수 표현식으로 작성하여 사용할 수 있습니다.