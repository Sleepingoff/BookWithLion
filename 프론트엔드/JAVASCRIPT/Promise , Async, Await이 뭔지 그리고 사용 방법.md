# Promise , Async, Await이 뭔지 그리고 사용 방법을 설명해주세요.

이지은(AI)

💡 #Promise #Async #Await

## **답변 드리겠습니다!**

<aside>
📌 (300자)
Promise는 대기(Pending), 이행(Fulfilled), 거부(Rejected) 세 가지 상태로 비동기 작업의 결과를 표현하는 객체입니다. 대기는 비동기 작업이 아직 완료되지 않은 상태, 이행은 비동기 작업이 성공적으로 완료된 상태, 거부는 비동기 작업이 실패한 상태입니다. Promise의 주요 메서드는 **`then()`**과 **`catch()`**로 **`then()`** 은 Promise가 이행될 때 실행되며, **`catch()`** 메서드는 Promise가 거부될 때 실행됩니다. async 함수에 비동기 처리되는 부분에 `**await`** 키워드를 사용하여 동기식으로 표현함으로써 더 간결하게 쓸 수 있습니다.

</aside>

## **이런 질문도 나올 수 있어요!**

### promise와 Async, Await의 차이를 설명해주세요.

**1. 비동기 코드 작성 방식:**

- **Promise:** Promise는 비동기 작업의 결과를 다루기 위한 객체로, **`.then()`** 및 **`.catch()`**와 같은 메서드를 사용하여 비동기 코드를 처리합니다. Promise를 사용하면 코드가 상대적으로 명시적으로 작성됩니다.
- **async/await:** async/await는 ES2017(ES8)에서 추가된 문법으로, 비동기 코드를 동기식 코드와 유사한 형태로 작성할 수 있게 해줍니다. async 함수 내에서 **`await`** 키워드를 사용하여 Promise가 이행될 때까지 기다린 후 결과를 반환하므로 코드가 더 읽기 쉽고 구조화됩니다.

**2. 에러 처리:**

- **Promise:** Promise에서 에러 처리는 **`.catch()`** 메서드나 **`.then()`** 메서드 내부에서 **`reject`**된 경우에 가능합니다. 이로 인해 에러 처리 코드가 비동기 코드와 분리되어 있을 수 있습니다.
- **async/await:** async/await는 **`try...catch`** 블록 내에서 에러 처리를 수행할 수 있으므로, 에러 처리가 비동기 코드와 밀접하게 연결되어 있습니다.

**3. 가독성:**

- **Promise:** Promise를 사용하는 코드는 **`.then()`** 체인을 형성하며, 여러 개의 비동기 작업이 연달아 수행될 때 코드가 들여쓰기된 형태로 복잡해질 수 있습니다.
- **async/await:** async/await를 사용하면 코드가 선형적으로 나타나므로 가독성이 향상됩니다. 코드가 동기식 코드와 유사하게 보이기 때문에 비동기 로직을 이해하기가 더 쉬워집니다.

**4. 중첩된 비동기 작업:**

- **Promise:** 중첩된 비동기 작업을 처리할 때 Promise를 중첩해서 사용하면 "콜백 지옥"과 비슷한 형태가 될 수 있습니다. 이를 "Promise Hell"이라고 부릅니다.
- **async/await:** async/await를 사용하면 중첩된 비동기 작업을 보다 간단하게 처리할 수 있으며, 코드의 가독성이 향상됩니다.

종합적으로, async/await는 Promise를 기반으로 하되 비동기 코드를 더 간결하고 가독성 있게 작성할 수 있게 해주는 문법적인 향상을 제공합니다. 코드의 구조와 가독성을 향상시키면서 에러 처리도 간편하게 할 수 있으므로, 모던 자바스크립트 개발에서 많이 사용되고 있습니다.

### promise.all()에 대해 설명해주세요.

**`Promise.all()`**은 여러 개의 Promise를 병렬로 실행하고, 모든 Promise가 이행될 때까지 기다린 후에 하나의 Promise로 반환하는 메서드입니다. 이것은 주로 여러 비동기 작업을 동시에 수행하고, 그 결과를 모아서 처리해야 할 때 유용합니다.

### Promise 와 Callback 차이를 설명하시오.

**1. 가독성과 유지보수성:**

- **Promise:** Promise는 비동기 코드의 가독성과 유지보수성을 향상시킵니다. **`.then()`** 및 **`.catch()`**를 사용하여 비동기 작업의 성공과 실패를 처리하기 때문에 코드는 더 구조화되며, 에러 처리는 **`.catch()`** 블록에서 명시적으로 이루어집니다. 이로 인해 코드가 보다 예측 가능하고 읽기 쉬워집니다.
- **콜백:** 콜백은 콜백 지옥(callback hell)과 같은 형태로 코드가 중첩되기 쉽습니다. 여러 개의 비동기 작업이 연속적으로 실행될 때 코드는 들여쓰기로 인해 복잡해질 수 있으며, 에러 처리도 각 콜백 함수 내에서 따로 처리해야 합니다.

**2. 에러 처리:**

- **Promise:** Promise는 에러 처리를 더 쉽게 만듭니다. **`.catch()`** 메서드를 사용하여 모든 Promise에서 발생하는 에러를 중앙에서 처리할 수 있으므로, 에러 처리 코드의 중복을 줄일 수 있습니다.
- **콜백:** 콜백에서 에러를 처리하려면 각 콜백 함수 내에서 에러 처리 코드를 작성해야 합니다. 이로 인해 에러 처리 코드의 중복과 오류 발생 가능성이 높아집니다.

**3. 병렬 처리:**

- **Promise:** Promise.all()과 같은 메서드를 사용하여 여러 개의 Promise를 병렬로 처리하는 것이 쉽습니다. 이로 인해 성능을 향상시키고 여러 비동기 작업의 결과를 동시에 수집할 수 있습니다.
- **콜백:** 콜백으로는 병렬 처리를 보다 어렵게 만들 수 있으며, 여러 비동기 작업의 결과를 효과적으로 수집하기 어려울 수 있습니다.

**4. 코드의 진행 흐름:**

- **Promise:** Promise를 사용하면 비동기 코드를 동기식 코드와 유사한 흐름으로 작성할 수 있습니다. **`.then()`** 체인을 사용하여 코드가 연속적으로 실행되도록 할 수 있습니다.
- **콜백:** 콜백은 비동기 코드의 흐름을 이해하기가 어려울 수 있습니다. 중첩된 콜백 함수의 실행 순서를 이해하기 위해 추가 노력이 필요할 수 있습니다.